(defvar *response* nil)(defvar *response-time* nil)(defconstant *unit4-exp-data* '(2.25 2.8  2.3  2.75                                2.55 2.95 2.55 2.95))(defvar *demo4-study-set*   '("The painter visited the missionary"     "The missionary refused the painter"     "The painter was chased by the missionary"     "The painter was protected by the sailor"     "The missionary shot the sailor"     "The cannibal questioned the painter"     "The missionary was accused by the painter"     "The cannibal was feared by the missionary"))(defvar *demo4-test-set*   '((1 "k" "The painter visited the missionary")     (2 "k" "The painter was refused by the missionary")     (3 "k" "The missionary chased the painter")     (4 "k" "The painter was protected by the sailor")     (5 "d" "The sailor shot the missionary")     (6 "d" "The cannibal was questioned by the painter")     (7 "d" "The missionary accused the painter")     (8 "d" "The missionary was feared by the cannibal")))(defun study-sentence (text time)  (if *actr-enabled-p*      (study-sentence-model text time)    (study-sentence-person text time)))(defun study-sentence-model (text time)  (let ((window (open-exp-window "Sentence Experiment" :visible t :width 500)))    (install-device window)    (add-text-to-exp-window :text text :x 25 :y 150 :width 250)    (proc-display :clear t)    (run-full-time time :real-time t)))(defun study-sentence-person (text time)  (let ((window (open-exp-window "Sentence Experiment" :visible t :width 500)))    (add-text-to-exp-window :text text :x 25 :y 150 :width 250)    (sleep time)))(defun test-sentence (test)  (if *actr-enabled-p*      (test-sentence-model test)    (test-sentence-person test))) (defun test-sentence-model (test)  (let ((window (open-exp-window "Sentence Experiment" :visible t :width 500)))    (install-device window)    (add-text-to-exp-window :text (third test) :x 25 :y 150 :width 250)    (proc-display :clear t)        (setf *response-time* nil)    (setf *response* nil)        (let ((start-time (get-time)))      (run 30 :real-time t)      (setf *response-time* (if *response-time*                                  (- *response-time* start-time)                              30000)))        (list (first test) (/ *response-time* 1000.0)          (string-equal *response* (second test)))))(defun test-sentence-person (test)  (let ((window (open-exp-window "Sentence Experiment" :visible t :width 500)))    (add-text-to-exp-window :text (third test) :x 25 :y 150 :width 250)        (setf *response-time* nil)    (setf *response* nil)    (sgp :v nil)    (let ((start-time (get-time)))       (while (null *response*)             (allow-event-manager window))      (setf *response-time* (- *response-time* start-time)))        (list (first test) (/ *response-time* 1000.0)          (string-equal *response* (second test)))))(defun study-sentences (set time)   (dolist (x set)     (study-sentence x time)))(defun test-sentences (set)   (let ((results nil))     (dolist (x set)       (push (test-sentence x) results))     (mapcar #'cdr (sort results #'< :key #'first))))(defun do-experiment (&key (in-order t))  (let ((study (if in-order                   *demo4-study-set*                 (permute-list *demo4-study-set*)))        (tests (if in-order                   *demo4-test-set*                 (permute-list *demo4-test-set*))))        (reset)    (setf *actr-enabled-p* t)    (study-sentences study 5)    (study-sentence "                            test" 2)    (report-data (test-sentences tests)))) (defun report-data (lis)   (let ((rts (mapcar #'first lis)))     (correlation rts *unit4-exp-data*)     (mean-deviation rts *unit4-exp-data*)     (format t "          Active-Active Active-Passive Passive-Active Passive-Passive~%")     (format t "True: ~:{~9,2F (~3s)~}~%" (subseq lis 0 4))     (format t "False:~:{~9,2F (~3s)~}~%" (subseq lis 4 8))))(defmethod rpm-window-key-event-handler ((win rpm-window) key)  (setf *response-time* (get-time))  (setf *response* (string key)))(clear-all)(reset)(define-model comPro(sgp :v t :esc t :lf 0.15 :ga 0.0 :show-focus t)(chunk-type comprehend-sentence agent action object purpose word state)(chunk-type meaning word)(add-dm    (painter ISA meaning word "painter")    (missionary ISA meaning word "missionary")    (sailor ISA meaning word "sailor")    (cannibal ISA meaning word "cannibal")    (visit ISA meaning word "visited")    (refuse ISA meaning word "refused")    (chase ISA meaning word "chased")    (shoot ISA meaning word "shot")    (question ISA meaning word "questioned")    (accuse ISA meaning word "accused")    (fear ISA meaning word "feared")    (protect ISA meaning word "protected")    (test ISA meaning word "test")    (goal ISA comprehend-sentence purpose "study"))(P found-new-word    =goal>       ISA         comprehend-sentence       state       nil    =visual-location>       ISA         visual-location    ?visual>       state    free==>   -manual>   =goal>       state       "attending"    +visual>       ISA         move-attention       screen-pos  =visual-location)(P find-next-word    =goal>       ISA         comprehend-sentence       state       "find"==>    +visual-location>       ISA         visual-location    > screen-x  current       :nearest     current    =goal>       state       "looking")(P attend-word    =goal>       ISA         comprehend-sentence       state       "looking"    =visual-location>       ISA         visual-location    ?visual>       state    free==>    =goal>       state       "attending"    +visual>       ISA         move-attention       screen-pos  =visual-location)(P read-word    =goal>       ISA         comprehend-sentence       state       "attending"       word        nil    =visual>       ISA         text       value       =word==>    -visual-location>    =goal>       word        =word       state       "read"    +retrieval>       ISA         meaning       word        =word)(P skip-the    =goal>       ISA         comprehend-sentence       word        "the"       state       "read"==>    =goal>       state       "find"       word        nil   )(P skip-was    =goal>       ISA         comprehend-sentence       word        "was"       state       "read"==>    =goal>       state       "find"       word        nil   );;; When the model encounter a word by;;; it would skip the word and it would;;; undersant that the sentense is a passive voice sentence;;; it would switch the object with agent. For this production;;; so far the model undersantds that the agent is the object.(P skip-by    =goal>       ISA         comprehend-sentence       word        "by"       state       "read"       agent       =agent==>    =goal>       state       "find"       word        nil       object     =agent   )(P respond-to-test    =goal>       ISA         comprehend-sentence       word        "test"    =retrieval>       ISA         meaning       word        "test"==>   -visual>   +goal>       ISA         comprehend-sentence       purpose     "test")(P process-first-noun    =goal>       ISA         comprehend-sentence       agent       nil       action      nil       word        =word     - word        "test"       state       "read"    =retrieval>       ISA         meaning       word        =word==>    =goal>       agent       =retrieval       word        nil       state       "find")(P process-verb    =goal>       ISA         comprehend-sentence       agent       =val       action      nil       word        =word       state       "read"    =retrieval>       ISA         meaning       word        =word==>    =goal>       action      =retrieval       word        nil       state       "find");;; This production will be fired for only active voice sentences;;; because the object is nill.(P process-last-word-object    =goal>       ISA         comprehend-sentence       object      nil       agent       =agent       action      =action       word        =word       state       "read"    =retrieval>       ISA         meaning       word        =word==>    =goal>       state       "sentence-complete"       object      =retrieval      );;; This production will be fired for only passive voice sentences;;; because we reached a state were we have the last word and the object is;;; not nil then this last word actually is the agent.(P process-last-word-object-passive    =goal>       ISA         comprehend-sentence       - object      nil       agent       =agent       action      =action       word        =word       state       "read"    =retrieval>       ISA         meaning       word        =word==>    =goal>       state       "sentence-complete"       agent      =retrieval)(P study-sentence-read-wait    =goal>       ISA         comprehend-sentence       state       "sentence-complete"       purpose     "study"==>    -visual>    +goal>       ISA         comprehend-sentence       purpose     "study");;; This production will be fired only when we have comprehend-sentence chunck;;; and its state is sentence-complete and of purpose test.;;; When this production fires it would call the retrival to recall a sentence from;;; the declarative memory that maches the sentence in the goal buffer. It also sets the goal purpose;;; to purpose verify which will triger farther production to do the verification.(P test-sentence-read-wait    =goal>       ISA         comprehend-sentence       state       "sentence-complete"       purpose     "test"       action      =action       agent       =agent       object      =object==>    -visual>    +goal>       ISA         comprehend-sentence       purpose     "verify"    +retrieval>       ISA         comprehend-sentence       action      =action       object      =object       agent       =agent       purpose      "study");;; This production will be fired when we have in goal buffer a comprehend-sentence with purpose;;; verify and the retrieval buffer has a comprehend-sentence of ;;; purpose study ( which means the retrival succeeded in finding the sentence). When this production;;; fires it would order the manual buffer to press on the k key using the right hand;;; and middle finger(P test-positive    =goal>       ISA         comprehend-sentence       purpose     "verify"    =retrieval>       ISA          comprehend-sentence       purpose      "study"==>    -visual>    +goal>       ISA         comprehend-sentence       purpose     "test"    +manual>      ISA        punch      hand       right      finger     middle);;; This production will be fired when we have in goal buffer a comprehend-sentence with purpose;;; verify and the retrieval buffer is empty and its state is not busy;;; ( which means the retrival failed in finding the sentence). When this production;;; fires it would order the manual buffer to press on the D key using the left hand;;; and middle finger(P test-negative    =goal>       ISA         comprehend-sentence       purpose     "verify"    ?retrieval>       buffer empty       - state  busy==>    -visual>    +goal>       ISA         comprehend-sentence       purpose     "test"    +manual>      ISA        punch      hand       left      finger     middle)(set-visloc-default isa visual-location :attended new screen-x lowest)(setf *actr-enabled-p* t)(goal-focus goal))